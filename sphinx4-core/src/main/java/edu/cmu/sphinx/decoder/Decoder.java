/*
 * Copyright 1999-2004 Carnegie Mellon University.
 * Portions Copyright 2004 Sun Microsystems, Inc.
 * Portions Copyright 2004 Mitsubishi Electric Research Laboratories.
 * All Rights Reserved.  Use is subject to license terms.
 *
 * See the file "license.terms" for information on usage and
 * redistribution of this file, and for a DISCLAIMER OF ALL
 * WARRANTIES.
 *
 */
package edu.cmu.sphinx.decoder;

import static java.util.logging.Logger.getLogger;

import edu.cmu.sphinx.decoder.search.SearchManager;
import edu.cmu.sphinx.result.Result;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Logger;

/**
 * The primary decoder class
 */
public class Decoder implements ResultProducer {

    private static final Logger LOGGER = getLogger(Decoder.class.getName());

    /** The property for the number of features to recognize at once. */
    private int featureBlockSize = Integer.MAX_VALUE;

    private final List<ResultListener> resultListeners = new ArrayList<>();
    SearchManager searchManager;
    /**
     * If set to <code>false</code> the used search-manager all registered
     * result listeners will be notified only for final results. Per default
     * non-final results don't trigger notification, because in most
     * application the utterance final result will be sufficient.
     * (defaultValue = false)
     */
    private final boolean fireNonFinalResults;
    private final String name;
    /**
     * Main decoder
     *
     * @param searchManager search manager to configure search space
     * @param fireNonFinalResults should we notify about non-final results
     * @param autoAllocate automatic allocation of all components
     * @param resultListeners listeners to get signals
     * @param featureBlockSize frequency of notification about results
     */
    public Decoder(SearchManager searchManager, boolean fireNonFinalResults, boolean autoAllocate, List<ResultListener> resultListeners, int featureBlockSize) {
        this.name = getClass().getName();
        this.searchManager = searchManager;
        this.fireNonFinalResults = fireNonFinalResults;
        this.featureBlockSize = featureBlockSize;
        if (autoAllocate) {
            searchManager.allocate();
        }
        for (ResultListener listener : resultListeners) {
            addResultListener(listener);
        }
    }


    /**
     * Allocate resources necessary for decoding
     */
    public void allocate() {
        searchManager.allocate();
    }


    /**
     * Deallocate resources
     */
    public void deallocate() {
        searchManager.deallocate();
    }


    /**
     * Adds a result listener to this recognizer. A result listener is called whenever a new result is generated by the
     * recognizer. This method can be called in any state.
     *
     * @param resultListener the listener to add
     */
    public void addResultListener(ResultListener resultListener) {
        resultListeners.add(resultListener);
    }


    /**
     * Removes a previously added result listener. This method can be called in any state.
     *
     * @param resultListener the listener to remove
     */
    public void removeResultListener(ResultListener resultListener) {
        resultListeners.remove(resultListener);
    }


    /**
     * Fires new results as soon as they become available.
     *
     * @param result the new result
     */
    void fireResultListeners(Result result) {
        if (fireNonFinalResults || result.isFinal()) {
            for (ResultListener resultListener : resultListeners) {
                resultListener.newResult(result);
            }
        } else {
            LOGGER.finer("skipping non-final result " + result);
        }
    }

    @Override
    public String toString() {
        return name;
    }

    /**
     * Decode frames until recognition is complete.
     *
     * @param referenceText the reference text (or null)
     * @return a result
     */
    public Result decode(String referenceText) {
        searchManager.startRecognition();
        Result result;
        do {
            result = searchManager.recognize(featureBlockSize);
            if (result != null) {
                result.setReferenceText(referenceText);
                fireResultListeners(result);
            }
        } while (result != null && !result.isFinal());
        searchManager.stopRecognition();
        return result;
    }
}
