/*
 * Copyright 1999-2004 Carnegie Mellon University.
 * Portions Copyright 2004 Sun Microsystems, Inc.
 * Portions Copyright 2004 Mitsubishi Electric Research Laboratories.
 * All Rights Reserved.  Use is subject to license terms.
 *
 * See the file "license.terms" for information on usage and
 * redistribution of this file, and for a DISCLAIMER OF ALL
 * WARRANTIES.
 *
 */
package edu.cmu.sphinx.linguist.acoustic.tiedstate;

import edu.cmu.sphinx.linguist.acoustic.Context;
import edu.cmu.sphinx.linguist.acoustic.HMM;
import edu.cmu.sphinx.linguist.acoustic.HMMPosition;
import edu.cmu.sphinx.linguist.acoustic.LeftRightContext;
import edu.cmu.sphinx.linguist.acoustic.Unit;
import edu.cmu.sphinx.linguist.acoustic.UnitManager;
import edu.cmu.sphinx.linguist.acoustic.tiedstate.tiedmixture.MixtureComponentSet;
import edu.cmu.sphinx.linguist.acoustic.tiedstate.tiedmixture.PrunableMixtureComponent;
import edu.cmu.sphinx.linguist.acoustic.tiedstate.tiedmixture.SetBasedGaussianMixture;
import edu.cmu.sphinx.util.ExtendedStreamTokenizer;
import edu.cmu.sphinx.util.LogMath;
import edu.cmu.sphinx.util.TimerPool;
import edu.cmu.sphinx.util.Utilities;
import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.URISyntaxException;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Properties;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * Loads a tied-state acoustic model generated by the Sphinx-3 trainer.
 * <p>
 * The acoustic model is stored as a directory specified by a URL. The
 * dictionary and language model files are not required to be in the package.
 * You can specify their locations separately.
 * <p>
 * Configuration file should set mandatory property of component: <b>location</b> -
 * this specifies the directory where the actual model
 * data files are. You can use <b>resource:</b> prefix to refer to files packed
 * inside jar or any other URI scheme.
 * The actual model data files are named "mdef", "means", "variances",
 * "transition_matrices", "mixture_weights".
 */

public class Sphinx3Loader implements ModelLoader {

  private static final Logger LOGGER = Logger.getLogger(Sphinx3Loader.class.getName());

  private static final String FILLER = "filler";
  private static final String SILENCE_CIPHONE = "SIL";

  /**
   * Supports this version of the acoustic model
   */
  private static final String MODEL_VERSION = "0.3";
  private static final String DENSITY_FILE_VERSION = "1.0";
  private static final String MIXW_FILE_VERSION = "1.0";
  private static final String TMAT_FILE_VERSION = "1.0";

  /**
   * Detects little/big endian of an S3 binary file
   */
  private static final int BYTE_ORDER_MAGIC = 0x11223344;

  private static final LogMath LOG_MATH = LogMath.getLogMath();

  private final UnitManager unitManager;

  /**
   * Number of top Gaussians to use in scoring
   */
  private final int topGaussiansNum;
  /**
   * Mixture component score floor.
   */
  private final float mixtureComponentScoreFloor;
  /**
   * Mixture weight floor
   */
  private final float mixtureWeightFloor;
  /**
   * Variance floor.
   */
  private final float varianceFloor;
  /**
   * The property specifying whether context-dependent units should be used.
   */
  private final boolean useContextDependentUnits;

  /**
   * @param unitManager Manages the set of {@link Unit Units} for a recognizer.
   * @param mixtureComponentScoreFloor Mixture component score floor. Default = 0.0f
   * @param mixtureWeightFloor Mixture weight floor. Default = 1e-7f
   * @param varianceFloor Variance floor. Default = 0.0001f
   * @param topGaussiansNum Number of top Gaussians to use in scoring. Default = 4
   * @param useContextDependentUnits The property specifying whether context-dependent units should be used. Default = true
   */
  public Sphinx3Loader(UnitManager unitManager, float mixtureComponentScoreFloor, float mixtureWeightFloor, float varianceFloor, int topGaussiansNum, boolean useContextDependentUnits) {
    this.unitManager = unitManager;
    this.mixtureComponentScoreFloor = mixtureComponentScoreFloor;
    this.mixtureWeightFloor = mixtureWeightFloor;
    this.varianceFloor = varianceFloor;
    this.topGaussiansNum = topGaussiansNum;
    this.useContextDependentUnits = useContextDependentUnits;
  }

  /**
   * Loads the sphinx3 density file, a set of density arrays are created and
   * placed in the given pool.
   *
   * @param buffer the open input stream to use
   * @param useCDUnits if true, loads also the context dependent units
   * @param senonePool Initialized Pool of Senones
   * @throws FileNotFoundException if a file cannot be found
   * @throws IOException if an error occurs while loading the data
   */
  private static HmmData loadHMMPool(byte[] buffer, boolean useCDUnits, GaussianWeights mixtureWeights, Pool<float[][]> transitionsPool, UnitManager unitManager, Pool<Senone> senonePool)
      throws IOException {
    if (buffer == null) {
      throw new Sphinx3ModelException("can't find model definition");
    }
    ExtendedStreamTokenizer est = new ExtendedStreamTokenizer(new ByteArrayInputStream(buffer), '#', false);

    LOGGER.fine("Loading HMM file");

    est.expectString(MODEL_VERSION);

    int numBase = est.getInt("numBase");
    est.expectString("n_base");

    int numTri = est.getInt("numTri");
    est.expectString("n_tri");

    int numStateMap = est.getInt("numStateMap");
    est.expectString("n_state_map");

    int numTiedState = est.getInt("numTiedState");
    est.expectString("n_tied_state");

    int numContextIndependentTiedState = est.getInt("numContextIndependentTiedState");
    est.expectString("n_tied_ci_state");

    int numTiedTransitionMatrices = est.getInt("numTiedTransitionMatrices");
    est.expectString("n_tied_tmat");

    int numStatePerHMM = numStateMap / (numTri + numBase);

    assert numTiedState == mixtureWeights.getStatesNum();
    assert numTiedTransitionMatrices == transitionsPool.size();
    HmmData hmmData = new HmmData();

    // Load the base phones
    for (int i = 0; i < numBase; i++) {
      String name = est.getString();
      String left = est.getString();
      String right = est.getString();
      String position = est.getString();
      String attribute = est.getString();
      int tmat = est.getInt("tmat");

      int[] stid = new int[numStatePerHMM - 1];

      for (int j = 0; j < numStatePerHMM - 1; j++) {
        stid[j] = est.getInt("j");
        assert stid[j] >= 0 && stid[j] < numContextIndependentTiedState;
      }
      est.expectString("N");

      assert left.equals("-");
      assert right.equals("-");
      assert position.equals("-");
      assert tmat < numTiedTransitionMatrices;

      Unit unit = unitManager.getUnit(name, attribute.equals(FILLER));
      hmmData.contextIndependentUnits.put(unit.getName(), unit);

      if (LOGGER.isLoggable(Level.FINE)) {
        LOGGER.fine("Loaded " + unit);
      }

      // The first filler
      if (unit.isFiller() && unit.getName().equals(SILENCE_CIPHONE)) {
        unit = UnitManager.SILENCE;
      }

      float[][] transitionMatrix = transitionsPool.get(tmat);
      SenoneSequence ss = getSenoneSequence(stid, senonePool);

      HMM hmm = new SenoneHMM(unit, ss, transitionMatrix, HMMPosition.lookup(position));
      hmmData.hmmManager.put(hmm);
    }

    if (hmmData.hmmManager.get(HMMPosition.UNDEFINED, UnitManager.SILENCE) == null) {
      throw new Sphinx3ModelException("Could not find SIL unit in acoustic model");
    }

    // Load the context dependent phones. If the useCDUnits
    // property is false, the CD phones will not be created, but
    // the values still need to be read in from the file.

    String lastUnitName = "";
    Unit lastUnit = null;
    int[] lastStid = null;
    SenoneSequence lastSenoneSequence = null;

    for (int i = 0; i < numTri; i++) {
      String name = est.getString();
      String left = est.getString();
      String right = est.getString();
      String position = est.getString();
      String attribute = est.getString();
      int tmat = est.getInt("tmat");

      int[] stid = new int[numStatePerHMM - 1];

      for (int j = 0; j < numStatePerHMM - 1; j++) {
        stid[j] = est.getInt("j");
        assert stid[j] >= numContextIndependentTiedState
            && stid[j] < numTiedState;
      }
      est.expectString("N");

      assert !left.equals("-");
      assert !right.equals("-");
      assert !position.equals("-");
      assert attribute.equals("n/a");
      assert tmat < numTiedTransitionMatrices;

      if (useCDUnits) {
        Unit unit;
        String unitName = (name + ' ' + left + ' ' + right);

        if (unitName.equals(lastUnitName)) {
          unit = lastUnit;
        } else {
          Unit[] leftContext = new Unit[1];
          leftContext[0] = hmmData.contextIndependentUnits.get(left);

          Unit[] rightContext = new Unit[1];
          rightContext[0] = hmmData.contextIndependentUnits.get(right);

          Context context = LeftRightContext.get(leftContext, rightContext);
          unit = unitManager.getUnit(name, false, context);
        }
        lastUnitName = unitName;
        lastUnit = unit;

        if (LOGGER.isLoggable(Level.FINE)) {
          LOGGER.fine("Loaded " + unit);
        }

        float[][] transitionMatrix = transitionsPool.get(tmat);

        SenoneSequence ss = lastSenoneSequence;
        if (ss == null || !sameSenoneSequence(stid, lastStid)) {
          ss = getSenoneSequence(stid, senonePool);
        }
        lastSenoneSequence = ss;
        lastStid = stid;

        HMM hmm = new SenoneHMM(unit, ss, transitionMatrix,
            HMMPosition.lookup(position));
        hmmData.hmmManager.put(hmm);
      }
    }
    est.close();
    return hmmData;
  }

  /**
   * Loads the transition matrices (Binary).
   *
   * @param buffer the buffer to the transitions matrices
   * @return a pool of transition matrices
   */
  private static Pool<float[][]> loadTransitionMatrices(byte[] buffer) {
    LOGGER.fine("Loading transition matrices from Transition matrix file");

    S3BinaryReader reader = S3BinaryReader.fromBuffer(buffer);

    if (!TMAT_FILE_VERSION.equals(reader.header.version)) {
      throw new Sphinx3ModelException("Unsupported version in Transition matrix file");
    }

    Pool<float[][]> pool = new Pool<>(ModelFile.TRANSITION_MATRICES.filename);

    int numMatrices = reader.readInt();
    int numRows = reader.readInt();
    int numStates = reader.readInt();
    int numValues = reader.readInt();

    assert numValues == numStates * numRows * numMatrices;

    for (int i = 0; i < numMatrices; i++) {
      float[][] tmat = new float[numStates][];
      // last row should be zeros
      tmat[numStates - 1] = new float[numStates];
      Sphinx3Loader.LOG_MATH.linearToLog(tmat[numStates - 1]);

      for (int j = 0; j < numRows; j++) {
        tmat[j] = reader.readFloatArray(numStates);
        Utilities.nonZeroFloor(tmat[j], 0f);
        Utilities.normalize(tmat[j]);
        Sphinx3Loader.LOG_MATH.linearToLog(tmat[j]);
      }
      pool.put(i, tmat);
    }

    reader.validateChecksum();
    return pool;
  }

  /**
   * Loads the mixture weights (Binary).
   *
   * @param buffer the buffer to the mixture weight file
   * @param floor the minimum mixture weight allowed
   * @return a pool of mixture weights
   * @throws IOException if an error occurs while loading the data
   */
  private static GaussianWeights loadMixtureWeights(byte[] buffer, float floor) throws IOException {
    S3BinaryReader reader = S3BinaryReader.fromBuffer(buffer);

    if (!MIXW_FILE_VERSION.equals(reader.header.version)) {
      throw new IOException("Unsupported version in Gaussian mixture weights file");
    }

    int numStates = reader.readInt();
    int numStreams = reader.readInt();
    int numGaussiansPerState = reader.readInt();
    int numValues = reader.readInt();
    GaussianWeights mixtureWeights = new GaussianWeights(ModelFile.MIXTURE_WEIGHTS.filename, numStates, numGaussiansPerState, numStreams);

    LOGGER.fine("Number of states " + numStates);
    LOGGER.fine("Number of streams " + numStreams);
    LOGGER.fine("Number of gaussians per state " + numGaussiansPerState);

    assert numValues == numStates * numStreams * numGaussiansPerState;

    for (int i = 0; i < numStates; i++) {
      for (int j = 0; j < numStreams; j++) {
        float[] logStreamMixtureWeight = reader.readFloatArray(numGaussiansPerState);
        Utilities.normalize(logStreamMixtureWeight);
        Utilities.floorData(logStreamMixtureWeight, floor);
        Sphinx3Loader.LOG_MATH.linearToLog(logStreamMixtureWeight);
        mixtureWeights.put(i, j, logStreamMixtureWeight);
      }
    }

    reader.validateChecksum();
    return mixtureWeights;
  }

  /**
   * Creates the senone pool from the rest of the pools.
   *
   * @param distFloor the lowest allowed score
   * @param varianceFloor the lowest allowed variance
   * @return the senone pool
   */
  private static Pool<Senone> createSenonePool(float distFloor, float varianceFloor, Pool<float[]> meansPool, Pool<float[]> variancePool, GaussianWeights mixtureWeights) {
    Pool<Senone> pool = new Pool<>("senones");

    int numMeans = meansPool.size();
    int numVariances = variancePool.size();
    int numGaussiansPerSenone = mixtureWeights.getGauPerState();
    int numSenones = mixtureWeights.getStatesNum();
    int numStreams = mixtureWeights.getStreamsNum();
    int whichGaussian = 0;

    LOGGER.fine("Senones " + numSenones);
    LOGGER.fine("Gaussians Per Senone " + numGaussiansPerSenone);
    LOGGER.fine("Means " + numMeans);
    LOGGER.fine("Variances " + numVariances);

    assert numGaussiansPerSenone > 0;
    assert numVariances == numSenones * numGaussiansPerSenone;
    assert numMeans == numSenones * numGaussiansPerSenone;

    for (int i = 0; i < numSenones; i++) {
      MixtureComponent[] mixtureComponents = new MixtureComponent[numGaussiansPerSenone * numStreams];
      for (int j = 0; j < numGaussiansPerSenone; j++) {
        mixtureComponents[j] = new MixtureComponent(meansPool.get(whichGaussian), variancePool.get(whichGaussian), distFloor, varianceFloor);
        whichGaussian++;
      }

      Senone senone = new GaussianMixture(mixtureWeights, mixtureComponents, i);
      pool.put(i, senone);
    }
    return pool;
  }

  /**
   * Creates the tied senone pool from the rest of the pools.
   *
   * @param distFloor the lowest allowed score
   * @param varianceFloor the lowest allowed variance
   * @return the senone pool
   */
  private static Pool<Senone> createTiedSenonePool(float distFloor, float varianceFloor, Pool<float[]> meansPool, Pool<float[]> variancePool, GaussianWeights mixtureWeights, int topGauNum,
      SenoneToCIPhone senoneToCIPhone) {
    Pool<Senone> pool = new Pool<>("senones");
    int numMeans = meansPool.size();
    int numVariances = variancePool.size();
    int numGaussiansPerState = mixtureWeights.getGauPerState();
    int numSenones = mixtureWeights.getStatesNum();
    int numStreams = mixtureWeights.getStreamsNum();

    LOGGER.fine("Senones " + numSenones);
    LOGGER.fine("Gaussians Per State " + numGaussiansPerState);
    LOGGER.fine("Means " + numMeans);
    LOGGER.fine("Variances " + numVariances);

    int numBase = senoneToCIPhone.numberOfBase;
    assert numGaussiansPerState > 0;
    assert numVariances == numBase * numGaussiansPerState * numStreams;
    assert numMeans == numBase * numGaussiansPerState * numStreams;

    MixtureComponentSet[] phoneticTiedMixtures = new MixtureComponentSet[numBase];
    for (int i = 0; i < numBase; i++) {
      ArrayList<PrunableMixtureComponent[]> mixtureComponents = new ArrayList<>();
      for (int j = 0; j < numStreams; j++) {
        PrunableMixtureComponent[] featMixtureComponents = new PrunableMixtureComponent[numGaussiansPerState];
        for (int k = 0; k < numGaussiansPerState; k++) {
          int whichGaussian = i * numGaussiansPerState * numStreams + j * numGaussiansPerState + k;
          featMixtureComponents[k] = new PrunableMixtureComponent(
              meansPool.get(whichGaussian),
              variancePool.get(whichGaussian),
              distFloor, varianceFloor, k);
        }
        mixtureComponents.add(featMixtureComponents);
      }
      phoneticTiedMixtures[i] = new MixtureComponentSet(mixtureComponents, topGauNum);
    }

    for (int i = 0; i < numSenones; i++) {
      Senone senone = new SetBasedGaussianMixture(mixtureWeights, phoneticTiedMixtures[senoneToCIPhone.senone2ci[i]], i);
      pool.put(i, senone);
    }
    return pool;
  }

  /**
   * Returns true if the given senone sequence IDs are the same.
   *
   * @param ssid1 ids of first senone sequence
   * @param ssid2 ids of second senone sequence
   * @return true if the given senone sequence IDs are the same, false
   * otherwise
   */
  private static boolean sameSenoneSequence(int[] ssid1, int[] ssid2) {
    if (ssid1.length == ssid2.length) {
      for (int i = 0; i < ssid1.length; i++) {
        if (ssid1[i] != ssid2[i]) {
          return false;
        }
      }
      return true;
    } else {
      return false;
    }
  }

  /**
   * Gets the senone sequence representing the given senones.
   *
   * @param stateid is the array of senone state ids
   * @param senonePool Initialized Senone Pool
   * @return the senone sequence associated with the states
   */
  private static SenoneSequence getSenoneSequence(int[] stateid, Pool<Senone> senonePool) {
    Senone[] senones = new Senone[stateid.length];
    for (int i = 0; i < stateid.length; i++) {
      senones[i] = senonePool.get(stateid[i]);
    }
    return new SenoneSequence(senones);
  }

  /**
   * Loads the sphinx3 density file, a set of density arrays are created and
   * placed in the given pool.
   *
   * @param buffer the name of the data
   * @param floor the minimum density allowed
   * @param modelFile Type of the model file in the buffer
   * @return a pool of loaded densities
   * @throws FileNotFoundException if a file cannot be found
   * @throws IOException if an error occurs while loading the data
   */
  private Pool<float[]> loadDensityFile(byte[] buffer, float floor, ModelFile modelFile) throws IOException {
    final S3BinaryReader reader = S3BinaryReader.fromBuffer(buffer);

    if (!DENSITY_FILE_VERSION.equals(reader.header.version)) {
      throw new IOException(String.format("Unsupported version %s in %s", reader.header.version, modelFile));
    }

    int numStates = reader.readInt();
    int numStreams = reader.readInt();
    int numGaussiansPerState = reader.readInt();

    int[] vectorLength = new int[numStreams];
    for (int i = 0; i < numStreams; i++) {
      vectorLength[i] = reader.readInt();
    }

    int rawLength = reader.readInt();

    LOGGER.fine("Number of states " + numStates);
    LOGGER.fine("Number of streams " + numStreams);
    LOGGER.fine("Number of gaussians per state " + numGaussiansPerState);
    LOGGER.fine("Vector length " + vectorLength.length);
    LOGGER.fine("Raw length " + rawLength);

    int blockSize = 0;
    for (int i = 0; i < numStreams; i++) {
      blockSize += vectorLength[i];
    }

    if (rawLength != numGaussiansPerState * blockSize * numStates) {
      throw new Sphinx3ModelException("Invalid Density file. Total data length is not equal to the sum of all parts.");
    }

    Pool<float[]> pool = new Pool<>(modelFile.filename);

    for (int i = 0; i < numStates; i++) {
      for (int j = 0; j < numStreams; j++) {
        for (int k = 0; k < numGaussiansPerState; k++) {
          float[] density = reader.readFloatArray(vectorLength[j]);
          Utilities.floorData(density, floor);
          pool.put(i * numStreams * numGaussiansPerState + j * numGaussiansPerState + k, density);
        }
      }
    }

    reader.validateChecksum();
    return pool;
  }

  private boolean hasTiedMixtures(Properties modelProps) {
    String modelType = modelProps.getProperty("-model", "cont");
    return modelType.equals("ptm");
  }

  /**
   * Creates senone to CI phone mapping, reading model definition file
   */
  private SenoneToCIPhone getSenoneToCIPhone(byte[] buffer, GaussianWeights mixtureWeights, Pool<float[][]> transitionsPool) throws IOException {
    if (buffer == null) {
      throw new IOException("Model definition data is missing");
    }

    try (InputStream inputStream = new ByteArrayInputStream(buffer)) {
      ExtendedStreamTokenizer est = new ExtendedStreamTokenizer(inputStream, '#', false);

      LOGGER.fine("Loading HMM file");

      est.expectString(MODEL_VERSION);

      int numBase = est.getInt("numBase");
      est.expectString("n_base");

      int numTri = est.getInt("numTri");
      est.expectString("n_tri");

      int numStateMap = est.getInt("numStateMap");
      est.expectString("n_state_map");

      int numTiedState = est.getInt("numTiedState");
      est.expectString("n_tied_state");

      est.getInt("numContextIndependentTiedState");
      est.expectString("n_tied_ci_state");

      int numTiedTransitionMatrices = est.getInt("numTiedTransitionMatrices");
      est.expectString("n_tied_tmat");

      int numStatePerHMM = numStateMap / (numTri + numBase);

      assert numTiedState == mixtureWeights.getStatesNum();
      assert numTiedTransitionMatrices == transitionsPool.size();

      int[] senone2ci = new int[numTiedState];
      // Load the base phones
      for (int i = 0; i < numBase + numTri; i++) {
        //TODO name this magic const somehow
        for (int j = 0; j < 5; j++) {
          est.getString();
        }
        int tmat = est.getInt("tmat");

        for (int j = 0; j < numStatePerHMM - 1; j++) {
          senone2ci[est.getInt("j")] = tmat;
        }
        est.expectString("N");

        assert tmat < numTiedTransitionMatrices;
      }

      est.close();
      return new SenoneToCIPhone(numBase, senone2ci);
    }

  }

  public Model load(ModelData modelData) throws IOException {
    TimerPool.getTimer(this, "Load AM").start();
    // do the actual acoustic model loading
    try {
      return loadModelFiles(modelData, unitManager);
    } catch (URISyntaxException e) {
      throw new RuntimeException(e);
    } finally {
      TimerPool.getTimer(this, "Load AM").stop();
    }

    // done
  }

  /**
   * Loads the AcousticModel from a directory in the file system.
   * <br>
   * Feature transformation matrices (feature_transform file) are not loaded.
   * These are used by an unused {@link edu.cmu.sphinx.frontend.DataProcessor}
   * as the last step to improve accuracy and performance but requires well trained data.
   *
   * @return Loaded {@link Sphinx3Model}
   * @throws IOException IO went wrong
   * @throws URISyntaxException uri was incorrectly specified
   */
  private Sphinx3Model loadModelFiles(ModelData modelData, UnitManager unitManager) throws IOException, URISyntaxException {
    Pool<float[]> meansPool = loadDensityFile(modelData.get(ModelFile.MEANS), -Float.MAX_VALUE, ModelFile.MEANS);
    Pool<float[]> variancePool = loadDensityFile(modelData.get(ModelFile.VARIANCES), varianceFloor, ModelFile.VARIANCES);
    LOGGER.fine("Loading mixture weights from: " + ModelFile.MIXTURE_WEIGHTS.filename);
    GaussianWeights mixtureWeights = loadMixtureWeights(modelData.get(ModelFile.MIXTURE_WEIGHTS), mixtureWeightFloor);
    Pool<float[][]> transitionsPool = loadTransitionMatrices(modelData.get(ModelFile.TRANSITION_MATRICES));
    final Properties modelProps = loadModelProps(modelData.get(ModelFile.FEAT_PARAMS));

    //create regular senone poll
    Pool<Senone> senonePool = hasTiedMixtures(modelProps)
        ? createTiedSenonePool(modelData, meansPool, mixtureWeights, transitionsPool, mixtureComponentScoreFloor, varianceFloor, variancePool)
        : createSenonePool(mixtureComponentScoreFloor, varianceFloor, meansPool, variancePool, mixtureWeights);

    // load the HMM modelDef file
    final HmmData data = loadHMMPool(modelData.get(ModelFile.MDEF), useContextDependentUnits, mixtureWeights, transitionsPool, unitManager, senonePool);
    return new Sphinx3Model(senonePool, data.hmmManager, data.contextIndependentUnits, modelProps);
  }

  private Pool<Senone> createTiedSenonePool(ModelData modelData, Pool<float[]> meansPool, GaussianWeights mixtureWeights, Pool<float[][]> transitionsPool, float mixtureComponentScoreFloor,
      float varianceFloor, Pool<float[]> variancePool) throws IOException {
    //create senone to CI mapping
    final SenoneToCIPhone senoneToCIPhone = getSenoneToCIPhone(modelData.get(ModelFile.MDEF), mixtureWeights, transitionsPool);
    //create tied senone pool
    return createTiedSenonePool(mixtureComponentScoreFloor, varianceFloor, meansPool, variancePool, mixtureWeights, topGaussiansNum, senoneToCIPhone);
  }

  private Properties loadModelProps(byte[] buffer) throws IOException {
    Properties props = new Properties();
    BufferedReader reader = new BufferedReader(new InputStreamReader(new ByteArrayInputStream(buffer)));
    String line;
    while ((line = reader.readLine()) != null) {
      String[] tokens = line.split(" ");
      props.put(tokens[0], tokens[1]);
    }
    return props;
  }

  static class SenoneToCIPhone {

    private final int numberOfBase;
    private final int[] senone2ci;

    public SenoneToCIPhone(int numberOfBase, int[] senone2ci) {
      this.numberOfBase = numberOfBase;
      this.senone2ci = senone2ci;
    }


  }

  static class S3BinaryHeader {

    final String checksum;
    final String version;

    S3BinaryHeader(String checksum, String version) {
      this.checksum = checksum;
      this.version = version;
    }
  }

  static class S3BinaryReader {

    private final ByteBuffer buffer;
    private final S3BinaryHeader header;
    private long calculatedChecksum = 0;

    private S3BinaryReader(byte[] buffer) {
      this.buffer = ByteBuffer.wrap(buffer);
      this.header = readS3BinaryHeader(this.buffer);
    }

    static S3BinaryReader fromBuffer(byte[] data) {
      return new S3BinaryReader(data);
    }

    /**
     * Reads the next word (text separated by whitespace) from the given stream.
     *
     * @return the next word
     */
    static String readWord(ByteBuffer buffer) {
      StringBuilder sb = new StringBuilder();
      char c;
      // skip leading whitespace
      do {
        if (!buffer.hasRemaining()) {
          return null;
        }
        c = (char) buffer.get();
      } while (Character.isWhitespace(c));
      // read the word
      do {
        sb.append(c);
        if (!buffer.hasRemaining()) {
          return null;
        }
        c = (char) buffer.get();
      } while (!Character.isWhitespace(c));
      return sb.toString();
    }

    /**
     * Reads the S3 binary header from the given location + path. Adds header
     * information to the given set of properties.
     *
     * @param buffer the name of the file
     * @return the input stream positioned after the header
     */
    public S3BinaryHeader readS3BinaryHeader(ByteBuffer buffer) {
      if (buffer == null) {
        throw new IllegalArgumentException("S3 data buffer cannot be null");
      }

      Properties props = new Properties();
      String id = readWord(buffer);
      if (!"s3".equals(id)) {
        throw new Sphinx3ModelException("Not proper s3 binary file " + buffer);
      }
      String name;
      while ((name = readWord(buffer)) != null) {
        if (!name.equals("endhdr")) {
          String value = readWord(buffer);
          props.setProperty(name, value);
        } else {
          break;
        }
      }
      int byteOrderMagic = buffer.getInt();
      if (byteOrderMagic == BYTE_ORDER_MAGIC) {
        LOGGER.fine("Not swapping " + buffer);
        return new S3BinaryHeader(props.getProperty("chksum0"), props.getProperty("version"));
      } else if (Utilities.swapInteger(byteOrderMagic) == BYTE_ORDER_MAGIC) {
        LOGGER.fine("Swapping  " + buffer);
        buffer.order(buffer.order() == ByteOrder.BIG_ENDIAN ? ByteOrder.LITTLE_ENDIAN : ByteOrder.BIG_ENDIAN);
        return new S3BinaryHeader(props.getProperty("chksum0"), props.getProperty("version"));
      } else {
        throw new Sphinx3ModelException("Corrupted S3 file " + buffer);
      }
    }

    /**
     * Read an integer from the input stream, byte-swapping as necessary.
     *
     * @return an integer value
     */
    public int readInt() {
      return readVal32();
    }

    /**
     * Read a float from the input stream, byte-swapping as necessary.
     *
     * @return a floating pint value
     */
    public float readFloat() {
      int val = readVal32();
      return Float.intBitsToFloat(val);
    }

    private int readVal32() {
      int val;
      val = buffer.getInt();
      calculatedChecksum = ((calculatedChecksum << 20 | calculatedChecksum >> 12) + val) & 0xFFFFFFFFL;
      return val;
    }

    /**
     * Reads the given number of floats from the stream and returns them in an
     * array of floats.
     *
     * @param size the number of floats to read
     * @return an array of size float elements
     */
    public float[] readFloatArray(int size) {
      float[] floats = new float[size];
      for (int i = 0; i < size; i++) {
        floats[i] = readFloat();
      }
      return floats;
    }

    /**
     * Validates checksum in the stream
     **/
    private void validateChecksum() {
      boolean doCheckSum = ("yes".equals(header.checksum));
      if (!doCheckSum) {
        return;
      }
      int oldCheckSum = (int) calculatedChecksum;
      int checkSum = buffer.getInt();
      if (checkSum != oldCheckSum) {
        throw new Sphinx3ModelException("Invalid checksum "
            + Long.toHexString(calculatedChecksum) + ", must be "
            + Integer.toHexString(checkSum));
      }
    }


  }

  static class HmmData {

    final Map<String, Unit> contextIndependentUnits = new LinkedHashMap<>();
    final HMMManager hmmManager = new HMMManager();
  }

}
